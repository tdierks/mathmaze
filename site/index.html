<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  background: #000;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var width = 480,
    height = 360;

var N = 1 << 0,
    S = 1 << 1,
    W = 1 << 2,
    E = 1 << 3;

var cellSize = 16,
    cellSpacing = 8,
    cellWidth = Math.floor((width - cellSpacing) / (cellSize + cellSpacing)),
    cellHeight = Math.floor((height - cellSpacing) / (cellSize + cellSpacing)),
    cells = generateMaze(cellWidth, cellHeight), // each cell’s edge bits
    distance = d3.range(cellWidth * cellHeight).map(function() { return 0; }),
    frontier = [(cellHeight - 1) * cellWidth];

var tokenSize = 8,
    playerX = 0,
    playerY = 0;

var canvas = d3.select("body").append("canvas")
    .attr("width", width)
    .attr("height", height);

var context = canvas.node().getContext("2d");

context.translate(
  Math.round((width - cellWidth * cellSize - (cellWidth + 1) * cellSpacing) / 2),
  Math.round((height - cellHeight * cellSize - (cellHeight + 1) * cellSpacing) / 2)
);

drawBoard();

document.body.addEventListener("keydown", function keyDownEvent(event) {
  var LEFT = 37, UP = 38, RIGHT = 39, DOWN = 40;
  var i = playerX + playerY * cellWidth;
  if (event.keyCode == RIGHT) {
    if (playerX+1 < cellWidth && (cells[i] & E)) {
      playerX += 1;
      drawBoard();
    }
  } else if (event.keyCode == LEFT) {
    if (playerX-1 >= 0 && (cells[i] & W)) {
      playerX -= 1;
      drawBoard();
    }
  } else if (event.keyCode == DOWN) {
    if (playerY+1 < cellHeight && (cells[i] & S)) {
      playerY += 1;
      drawBoard();
    }
  } else if (event.keyCode == UP) {
    if (playerY-1 >= 0 && (cells[i] & N)) {
      playerY -= 1;
      drawBoard();
    }
  }
});

function drawBoard() {
//   context.clearRect(0, 0, context.width, context.height);
  
  for (var y = 0, i = 0; y < cellHeight; ++y) {
    for (var x = 0; x < cellWidth; ++x, ++i) {
      context.fillStyle = "#888";
      fillCell(i);
      context.fillStyle = "#888";
      if (cells[i] & S) fillSouth(i);
      if (cells[i] & E) fillEast(i);
    }
  }

  drawPlayer();
}

// d3.timer(function() {
//   for (var i = 0; i < 50; ++i) {
//     if (exploreFrontier()) {
//       drawPlayer();
//       return true;
//     }
//   }
// });
// 
// function exploreFrontier() {
//   if ((i0 = popRandom(frontier)) == null) return true;
//   var i0,
//       i1,
//       d0 = distance[i0],
//       d1 = d0 + 1;
// 
//   context.fillStyle = d3.hsl(d0 % 360, 1, .5) + "";
//   fillCell(i0);
// 
//   context.fillStyle = d3.hsl(d1 % 360, 1, .5) + "";
//   if (cells[i0] & E && !distance[i1 = i0 + 1]) distance[i1] = d1, fillEast(i0), frontier.push(i1);
//   if (cells[i0] & W && !distance[i1 = i0 - 1]) distance[i1] = d1, fillEast(i1), frontier.push(i1);
//   if (cells[i0] & S && !distance[i1 = i0 + cellWidth]) distance[i1] = d1, fillSouth(i0), frontier.push(i1);
//   if (cells[i0] & N && !distance[i1 = i0 - cellWidth]) distance[i1] = d1, fillSouth(i1), frontier.push(i1);
// }

function fillCell(i) {
  var x = i % cellWidth, y = i / cellWidth | 0;
  context.fillRect(x * cellSize + (x + 1) * cellSpacing, y * cellSize + (y + 1) * cellSpacing, cellSize, cellSize);
}

function fillEast(i) {
  var x = i % cellWidth, y = i / cellWidth | 0;
  context.fillRect((x + 1) * (cellSize + cellSpacing), y * cellSize + (y + 1) * cellSpacing, cellSpacing, cellSize);
}

function fillSouth(i) {
  var x = i % cellWidth, y = i / cellWidth | 0;
  context.fillRect(x * cellSize + (x + 1) * cellSpacing, (y + 1) * (cellSize + cellSpacing), cellSize, cellSpacing);
}

function generateMaze(width, height) {
  var cells = new Array(width * height), // each cell’s edge bits
      remaining = d3.range(width * height), // cell indexes to visit
      previous = new Array(width * height); // current random walk

  // Add the starting cell.
  var start = remaining.pop();
  cells[start] = 0;

  // While there are remaining cells,
  // add a loop-erased random walk to the maze.
  while (!loopErasedRandomWalk());

  return cells;

  function loopErasedRandomWalk() {
    var i0,
        i1,
        x0,
        y0;

    // Pick a location that’s not yet in the maze (if any).
    do if ((i0 = remaining.pop()) == null) return true;
    while (cells[i0] >= 0);

    // Perform a random walk starting at this location,
    previous[i0] = i0;
    while (true) {
      x0 = i0 % width;
      y0 = i0 / width | 0;

      // picking a legal random direction at each step.
      i1 = Math.random() * 4 | 0;
      if (i1 === 0) { if (y0 <= 0) continue; --y0, i1 = i0 - width; }
      else if (i1 === 1) { if (y0 >= height - 1) continue; ++y0, i1 = i0 + width; }
      else if (i1 === 2) { if (x0 <= 0) continue; --x0, i1 = i0 - 1; }
      else { if (x0 >= width - 1) continue; ++x0, i1 = i0 + 1; }

      // If this new cell was visited previously during this walk,
      // erase the loop, rewinding the path to its earlier state.
      if (previous[i1] >= 0) eraseWalk(i0, i1);

      // Otherwise, just add it to the walk.
      else previous[i1] = i0;

      // If this cell is part of the maze, we’re done walking.
      if (cells[i1] >= 0) {

        // Add the random walk to the maze by backtracking to the starting cell.
        // Also erase this walk’s history to not interfere with subsequent walks.
        while ((i0 = previous[i1]) !== i1) {
          if (i1 === i0 + 1) cells[i0] |= E, cells[i1] |= W;
          else if (i1 === i0 - 1) cells[i0] |= W, cells[i1] |= E;
          else if (i1 === i0 + width) cells[i0] |= S, cells[i1] |= N;
          else cells[i0] |= N, cells[i1] |= S;
          previous[i1] = NaN;
          i1 = i0;
        }

        previous[i1] = NaN;
        return;
      }

      i0 = i1;
    }
  }

  function eraseWalk(i0, i2) {
    var i1;
    do i1 = previous[i0], previous[i0] = NaN, i0 = i1; while (i1 !== i2);
  }
}

function popRandom(array) {
  if (!array.length) return null;
  var n = array.length, i = Math.random() * n | 0, t;
  t = array[i], array[i] = array[n - 1], array[n - 1] = t;
  return array.pop();
}

d3.select(self.frameElement).style("height", height + "px");

function drawPlayer() {
  context.fillStyle = "#fff";
  context.fillRect(playerX * cellSize + (playerX + 1) * cellSpacing + (cellSize - tokenSize)/2, playerY * cellSize + (playerY + 1) * cellSpacing + (cellSize - tokenSize)/2, tokenSize, tokenSize);
}

</script>
</body>
</html>