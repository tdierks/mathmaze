<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  background: #000;
  color: #ddd;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var width = 480,
    height = 360;

var N = 1 << 0,
    S = 1 << 1,
    W = 1 << 2,
    E = 1 << 3;

var cellSize = 16,
    cellSpacing = 8,
    cellWidth = Math.floor((width - cellSpacing) / (cellSize + cellSpacing)),
    cellHeight = Math.floor((height - cellSpacing) / (cellSize + cellSpacing)),
    tokenSize = 8,
    game = {
      cells: [],  // each cell’s edge bits
      player: {},
      key: {},
      exit: {},
    };
//     distance = d3.range(cellWidth * cellHeight).map(function() { return 0; }),
//     frontier = [(cellHeight - 1) * cellWidth];

var canvas = d3.select("body").append("canvas")
    .attr("width", width)
    .attr("height", height);

var context = canvas.node().getContext("2d");

context.translate(
  Math.round((width - cellWidth * cellSize - (cellWidth + 1) * cellSpacing) / 2),
  Math.round((height - cellHeight * cellSize - (cellHeight + 1) * cellSpacing) / 2)
);

initLevel();

document.body.addEventListener("keydown", function keyDownEvent(event) {
  var LEFT = 37, UP = 38, RIGHT = 39, DOWN = 40;
  var i = game.player.x + game.player.y * cellWidth;
  if (event.keyCode == RIGHT) {
    if (game.player.x+1 < cellWidth && (game.cells[i] & E)) {
      game.player.x += 1;
      updateBoard();
    }
  } else if (event.keyCode == LEFT) {
    if (game.player.x-1 >= 0 && (game.cells[i] & W)) {
      game.player.x -= 1;
      updateBoard();
    }
  } else if (event.keyCode == DOWN) {
    if (game.player.y+1 < cellHeight && (game.cells[i] & S)) {
      game.player.y += 1;
      updateBoard();
    }
  } else if (event.keyCode == UP) {
    if (game.player.y-1 >= 0 && (game.cells[i] & N)) {
      game.player.y -= 1;
      updateBoard();
    }
  }
});

function initLevel() {
  game.cells = generateMaze(cellWidth, cellHeight);
  game.player = {
    x: 0,
    y: 0,
    hasKey: false,
    escaped: false,
  };
  game.key = {
    x: cellWidth-1,
    y: cellHeight-1,
  };
  if (Math.random() < 0.5) {
    game.key.x = 0;
  } else {
    game.key.y = 0;
  }
  game.exit = {
    x: cellWidth - 1,
    y: cellHeight - 1,
  };
  
  d3.timer(function drawTimer() {
    updateBoard();
    var announceSpan = d3.select("#announce").node();
    if (announceSpan) announceSpan.innerHTML = "";
    return true;
  });
}

function updateBoard() {
  var message = null;
  if (game.player.x == game.key.x && game.player.y == game.key.y) {
    game.player.hasKey = true;
    message = "You found a game.key!";
  }
  
  if (game.player.x == game.exit.x && game.player.y == game.exit.y) {
    if (game.player.hasKey == true) {
      game.player.escaped = true;
      
      message = "You escaped!";
      
      d3.timer(function resetLevel() {
        initLevel();
        return true;
      }, 3000);
    } else {
      message = "You need the key!";
    }
    
    var announceSpan = d3.select("#announce").node();
    if (announceSpan && message) announceSpan.innerHTML = message;
  }

  drawBoard();
  
  var playerSpan = d3.select("#playerPos").node();
  if (playerSpan) playerSpan.innerHTML =
    "x = " + game.player.x + ", y = " + game.player.y + (game.player.hasKey ? " has key" : "");
}

function drawBoard() {
  context.fillStyle = "#000";
  context.fillRect(0, 0, width, height);
  
  for (var y = 0, i = 0; y < cellHeight; ++y) {
    for (var x = 0; x < cellWidth; ++x, ++i) {
      context.fillStyle = "#888";
      fillCell(i);
      context.fillStyle = "#888";
      if (game.cells[i] & S) fillSouth(i);
      if (game.cells[i] & E) fillEast(i);
    }
  }

  drawExit();
  drawKey();
  drawPlayer();
}

function drawExit() {
  if (!game.player.escaped) {
    drawImage(game.exit.x, game.exit.y, "#exiticon");
  } else {
    drawImage(game.exit.x, game.exit.y, "#openexiticon");
  }
}

function drawPlayer() {
  if (!game.player.escaped) {
    drawImage(game.player.x, game.player.y, "#heroicon");
  }
}

function drawKey() {
  if (!game.player.hasKey) {
    drawImage(game.key.x, game.key.y, "#keyicon");
  }
}

function drawToken(x, y) {
  context.fillRect(x * cellSize + (x + 1) * cellSpacing + (cellSize - tokenSize)/2, y * cellSize + (y + 1) * cellSpacing + (cellSize - tokenSize)/2, tokenSize, tokenSize);
}

function drawImage(x, y, imageSel) {
  var image = d3.select(imageSel).node();
  if (image) {
    context.drawImage(image, x * cellSize + (x + 1) * cellSpacing, y * cellSize + (y + 1) * cellSpacing, cellSize, cellSize);
  }
}

// d3.timer(function() {
//   for (var i = 0; i < 50; ++i) {
//     if (exploreFrontier()) {
//       drawPlayer();
//       return true;
//     }
//   }
// });
// 
// function exploreFrontier() {
//   if ((i0 = popRandom(frontier)) == null) return true;
//   var i0,
//       i1,
//       d0 = distance[i0],
//       d1 = d0 + 1;
// 
//   context.fillStyle = d3.hsl(d0 % 360, 1, .5) + "";
//   fillCell(i0);
// 
//   context.fillStyle = d3.hsl(d1 % 360, 1, .5) + "";
//   if (game.cells[i0] & E && !distance[i1 = i0 + 1]) distance[i1] = d1, fillEast(i0), frontier.push(i1);
//   if (game.cells[i0] & W && !distance[i1 = i0 - 1]) distance[i1] = d1, fillEast(i1), frontier.push(i1);
//   if (game.cells[i0] & S && !distance[i1 = i0 + cellWidth]) distance[i1] = d1, fillSouth(i0), frontier.push(i1);
//   if (game.cells[i0] & N && !distance[i1 = i0 - cellWidth]) distance[i1] = d1, fillSouth(i1), frontier.push(i1);
// }

function fillCell(i) {
  var x = i % cellWidth, y = i / cellWidth | 0;
  context.fillRect(x * cellSize + (x + 1) * cellSpacing, y * cellSize + (y + 1) * cellSpacing, cellSize, cellSize);
}

function fillEast(i) {
  var x = i % cellWidth, y = i / cellWidth | 0;
  context.fillRect((x + 1) * (cellSize + cellSpacing), y * cellSize + (y + 1) * cellSpacing, cellSpacing, cellSize);
}

function fillSouth(i) {
  var x = i % cellWidth, y = i / cellWidth | 0;
  context.fillRect(x * cellSize + (x + 1) * cellSpacing, (y + 1) * (cellSize + cellSpacing), cellSize, cellSpacing);
}

function generateMaze(width, height) {
  var cells = new Array(width * height), // each cell’s edge bits
      remaining = d3.range(width * height), // cell indexes to visit
      previous = new Array(width * height); // current random walk

  // Add the starting cell.
  var start = remaining.pop();
  cells[start] = 0;

  // While there are remaining cells,
  // add a loop-erased random walk to the maze.
  while (!loopErasedRandomWalk());

  return cells;

  function loopErasedRandomWalk() {
    var i0,
        i1,
        x0,
        y0;

    // Pick a location that’s not yet in the maze (if any).
    do if ((i0 = remaining.pop()) == null) return true;
    while (cells[i0] >= 0);

    // Perform a random walk starting at this location,
    previous[i0] = i0;
    while (true) {
      x0 = i0 % width;
      y0 = i0 / width | 0;

      // picking a legal random direction at each step.
      i1 = Math.random() * 4 | 0;
      if (i1 === 0) { if (y0 <= 0) continue; --y0, i1 = i0 - width; }
      else if (i1 === 1) { if (y0 >= height - 1) continue; ++y0, i1 = i0 + width; }
      else if (i1 === 2) { if (x0 <= 0) continue; --x0, i1 = i0 - 1; }
      else { if (x0 >= width - 1) continue; ++x0, i1 = i0 + 1; }

      // If this new cell was visited previously during this walk,
      // erase the loop, rewinding the path to its earlier state.
      if (previous[i1] >= 0) eraseWalk(i0, i1);

      // Otherwise, just add it to the walk.
      else previous[i1] = i0;

      // If this cell is part of the maze, we’re done walking.
      if (cells[i1] >= 0) {

        // Add the random walk to the maze by backtracking to the starting cell.
        // Also erase this walk’s history to not interfere with subsequent walks.
        while ((i0 = previous[i1]) !== i1) {
          if (i1 === i0 + 1) cells[i0] |= E, cells[i1] |= W;
          else if (i1 === i0 - 1) cells[i0] |= W, cells[i1] |= E;
          else if (i1 === i0 + width) cells[i0] |= S, cells[i1] |= N;
          else cells[i0] |= N, cells[i1] |= S;
          previous[i1] = NaN;
          i1 = i0;
        }

        previous[i1] = NaN;
        return;
      }

      i0 = i1;
    }
  }

  function eraseWalk(i0, i2) {
    var i1;
    do i1 = previous[i0], previous[i0] = NaN, i0 = i1; while (i1 !== i2);
  }
}

function popRandom(array) {
  if (!array.length) return null;
  var n = array.length, i = Math.random() * n | 0, t;
  t = array[i], array[i] = array[n - 1], array[n - 1] = t;
  return array.pop();
}

d3.select(self.frameElement).style("height", height + "px");

</script>
<div>Player: <span id="playerPos"></span></div>
<div id="announce"></div>
<div style="display: none">
  <img id="keyicon" src="key.png">
  <img id="heroicon" src="hero.png">
  <img id="exiticon" src="exit.png">
  <img id="openexiticon" src="open-exit.png">
</div>
</body>
</html>